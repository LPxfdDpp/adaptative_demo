// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'theme.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$AdaptativeThemeDataTearOff {
  const _$AdaptativeThemeDataTearOff();

// ignore: unused_element
  _AdaptativeThemeData call(
      {@required AdaptativeColorMode colorMode,
      @required AdaptativeSizeMode sizeMode,
      @required double maxContentWidth,
      @required AdaptativeThemeTextStylesData text,
      @required AdaptativeThemeColorsData colors,
      @required AdaptativeThemeSpacingData spacing,
      @required AdaptativeThemeInsetsData insets,
      @required AdaptativeThemeDurationsData durations,
      @required AdaptativeThemeBorderRadiusData borderRadius}) {
    return _AdaptativeThemeData(
      colorMode: colorMode,
      sizeMode: sizeMode,
      maxContentWidth: maxContentWidth,
      text: text,
      colors: colors,
      spacing: spacing,
      insets: insets,
      durations: durations,
      borderRadius: borderRadius,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $AdaptativeThemeData = _$AdaptativeThemeDataTearOff();

/// @nodoc
mixin _$AdaptativeThemeData {
  AdaptativeColorMode get colorMode;
  AdaptativeSizeMode get sizeMode;
  double get maxContentWidth;
  AdaptativeThemeTextStylesData get text;
  AdaptativeThemeColorsData get colors;
  AdaptativeThemeSpacingData get spacing;
  AdaptativeThemeInsetsData get insets;
  AdaptativeThemeDurationsData get durations;
  AdaptativeThemeBorderRadiusData get borderRadius;

  $AdaptativeThemeDataCopyWith<AdaptativeThemeData> get copyWith;
}

/// @nodoc
abstract class $AdaptativeThemeDataCopyWith<$Res> {
  factory $AdaptativeThemeDataCopyWith(
          AdaptativeThemeData value, $Res Function(AdaptativeThemeData) then) =
      _$AdaptativeThemeDataCopyWithImpl<$Res>;
  $Res call(
      {AdaptativeColorMode colorMode,
      AdaptativeSizeMode sizeMode,
      double maxContentWidth,
      AdaptativeThemeTextStylesData text,
      AdaptativeThemeColorsData colors,
      AdaptativeThemeSpacingData spacing,
      AdaptativeThemeInsetsData insets,
      AdaptativeThemeDurationsData durations,
      AdaptativeThemeBorderRadiusData borderRadius});

  $AdaptativeThemeTextStylesDataCopyWith<$Res> get text;
  $AdaptativeThemeColorsDataCopyWith<$Res> get colors;
  $AdaptativeThemeSpacingDataCopyWith<$Res> get spacing;
  $AdaptativeThemeInsetsDataCopyWith<$Res> get insets;
  $AdaptativeThemeDurationsDataCopyWith<$Res> get durations;
  $AdaptativeThemeBorderRadiusDataCopyWith<$Res> get borderRadius;
}

/// @nodoc
class _$AdaptativeThemeDataCopyWithImpl<$Res>
    implements $AdaptativeThemeDataCopyWith<$Res> {
  _$AdaptativeThemeDataCopyWithImpl(this._value, this._then);

  final AdaptativeThemeData _value;
  // ignore: unused_field
  final $Res Function(AdaptativeThemeData) _then;

  @override
  $Res call({
    Object colorMode = freezed,
    Object sizeMode = freezed,
    Object maxContentWidth = freezed,
    Object text = freezed,
    Object colors = freezed,
    Object spacing = freezed,
    Object insets = freezed,
    Object durations = freezed,
    Object borderRadius = freezed,
  }) {
    return _then(_value.copyWith(
      colorMode: colorMode == freezed
          ? _value.colorMode
          : colorMode as AdaptativeColorMode,
      sizeMode: sizeMode == freezed
          ? _value.sizeMode
          : sizeMode as AdaptativeSizeMode,
      maxContentWidth: maxContentWidth == freezed
          ? _value.maxContentWidth
          : maxContentWidth as double,
      text:
          text == freezed ? _value.text : text as AdaptativeThemeTextStylesData,
      colors: colors == freezed
          ? _value.colors
          : colors as AdaptativeThemeColorsData,
      spacing: spacing == freezed
          ? _value.spacing
          : spacing as AdaptativeThemeSpacingData,
      insets: insets == freezed
          ? _value.insets
          : insets as AdaptativeThemeInsetsData,
      durations: durations == freezed
          ? _value.durations
          : durations as AdaptativeThemeDurationsData,
      borderRadius: borderRadius == freezed
          ? _value.borderRadius
          : borderRadius as AdaptativeThemeBorderRadiusData,
    ));
  }

  @override
  $AdaptativeThemeTextStylesDataCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $AdaptativeThemeTextStylesDataCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $AdaptativeThemeColorsDataCopyWith<$Res> get colors {
    if (_value.colors == null) {
      return null;
    }
    return $AdaptativeThemeColorsDataCopyWith<$Res>(_value.colors, (value) {
      return _then(_value.copyWith(colors: value));
    });
  }

  @override
  $AdaptativeThemeSpacingDataCopyWith<$Res> get spacing {
    if (_value.spacing == null) {
      return null;
    }
    return $AdaptativeThemeSpacingDataCopyWith<$Res>(_value.spacing, (value) {
      return _then(_value.copyWith(spacing: value));
    });
  }

  @override
  $AdaptativeThemeInsetsDataCopyWith<$Res> get insets {
    if (_value.insets == null) {
      return null;
    }
    return $AdaptativeThemeInsetsDataCopyWith<$Res>(_value.insets, (value) {
      return _then(_value.copyWith(insets: value));
    });
  }

  @override
  $AdaptativeThemeDurationsDataCopyWith<$Res> get durations {
    if (_value.durations == null) {
      return null;
    }
    return $AdaptativeThemeDurationsDataCopyWith<$Res>(_value.durations,
        (value) {
      return _then(_value.copyWith(durations: value));
    });
  }

  @override
  $AdaptativeThemeBorderRadiusDataCopyWith<$Res> get borderRadius {
    if (_value.borderRadius == null) {
      return null;
    }
    return $AdaptativeThemeBorderRadiusDataCopyWith<$Res>(_value.borderRadius,
        (value) {
      return _then(_value.copyWith(borderRadius: value));
    });
  }
}

/// @nodoc
abstract class _$AdaptativeThemeDataCopyWith<$Res>
    implements $AdaptativeThemeDataCopyWith<$Res> {
  factory _$AdaptativeThemeDataCopyWith(_AdaptativeThemeData value,
          $Res Function(_AdaptativeThemeData) then) =
      __$AdaptativeThemeDataCopyWithImpl<$Res>;
  @override
  $Res call(
      {AdaptativeColorMode colorMode,
      AdaptativeSizeMode sizeMode,
      double maxContentWidth,
      AdaptativeThemeTextStylesData text,
      AdaptativeThemeColorsData colors,
      AdaptativeThemeSpacingData spacing,
      AdaptativeThemeInsetsData insets,
      AdaptativeThemeDurationsData durations,
      AdaptativeThemeBorderRadiusData borderRadius});

  @override
  $AdaptativeThemeTextStylesDataCopyWith<$Res> get text;
  @override
  $AdaptativeThemeColorsDataCopyWith<$Res> get colors;
  @override
  $AdaptativeThemeSpacingDataCopyWith<$Res> get spacing;
  @override
  $AdaptativeThemeInsetsDataCopyWith<$Res> get insets;
  @override
  $AdaptativeThemeDurationsDataCopyWith<$Res> get durations;
  @override
  $AdaptativeThemeBorderRadiusDataCopyWith<$Res> get borderRadius;
}

/// @nodoc
class __$AdaptativeThemeDataCopyWithImpl<$Res>
    extends _$AdaptativeThemeDataCopyWithImpl<$Res>
    implements _$AdaptativeThemeDataCopyWith<$Res> {
  __$AdaptativeThemeDataCopyWithImpl(
      _AdaptativeThemeData _value, $Res Function(_AdaptativeThemeData) _then)
      : super(_value, (v) => _then(v as _AdaptativeThemeData));

  @override
  _AdaptativeThemeData get _value => super._value as _AdaptativeThemeData;

  @override
  $Res call({
    Object colorMode = freezed,
    Object sizeMode = freezed,
    Object maxContentWidth = freezed,
    Object text = freezed,
    Object colors = freezed,
    Object spacing = freezed,
    Object insets = freezed,
    Object durations = freezed,
    Object borderRadius = freezed,
  }) {
    return _then(_AdaptativeThemeData(
      colorMode: colorMode == freezed
          ? _value.colorMode
          : colorMode as AdaptativeColorMode,
      sizeMode: sizeMode == freezed
          ? _value.sizeMode
          : sizeMode as AdaptativeSizeMode,
      maxContentWidth: maxContentWidth == freezed
          ? _value.maxContentWidth
          : maxContentWidth as double,
      text:
          text == freezed ? _value.text : text as AdaptativeThemeTextStylesData,
      colors: colors == freezed
          ? _value.colors
          : colors as AdaptativeThemeColorsData,
      spacing: spacing == freezed
          ? _value.spacing
          : spacing as AdaptativeThemeSpacingData,
      insets: insets == freezed
          ? _value.insets
          : insets as AdaptativeThemeInsetsData,
      durations: durations == freezed
          ? _value.durations
          : durations as AdaptativeThemeDurationsData,
      borderRadius: borderRadius == freezed
          ? _value.borderRadius
          : borderRadius as AdaptativeThemeBorderRadiusData,
    ));
  }
}

/// @nodoc
class _$_AdaptativeThemeData implements _AdaptativeThemeData {
  const _$_AdaptativeThemeData(
      {@required this.colorMode,
      @required this.sizeMode,
      @required this.maxContentWidth,
      @required this.text,
      @required this.colors,
      @required this.spacing,
      @required this.insets,
      @required this.durations,
      @required this.borderRadius})
      : assert(colorMode != null),
        assert(sizeMode != null),
        assert(maxContentWidth != null),
        assert(text != null),
        assert(colors != null),
        assert(spacing != null),
        assert(insets != null),
        assert(durations != null),
        assert(borderRadius != null);

  @override
  final AdaptativeColorMode colorMode;
  @override
  final AdaptativeSizeMode sizeMode;
  @override
  final double maxContentWidth;
  @override
  final AdaptativeThemeTextStylesData text;
  @override
  final AdaptativeThemeColorsData colors;
  @override
  final AdaptativeThemeSpacingData spacing;
  @override
  final AdaptativeThemeInsetsData insets;
  @override
  final AdaptativeThemeDurationsData durations;
  @override
  final AdaptativeThemeBorderRadiusData borderRadius;

  @override
  String toString() {
    return 'AdaptativeThemeData(colorMode: $colorMode, sizeMode: $sizeMode, maxContentWidth: $maxContentWidth, text: $text, colors: $colors, spacing: $spacing, insets: $insets, durations: $durations, borderRadius: $borderRadius)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AdaptativeThemeData &&
            (identical(other.colorMode, colorMode) ||
                const DeepCollectionEquality()
                    .equals(other.colorMode, colorMode)) &&
            (identical(other.sizeMode, sizeMode) ||
                const DeepCollectionEquality()
                    .equals(other.sizeMode, sizeMode)) &&
            (identical(other.maxContentWidth, maxContentWidth) ||
                const DeepCollectionEquality()
                    .equals(other.maxContentWidth, maxContentWidth)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.colors, colors) ||
                const DeepCollectionEquality().equals(other.colors, colors)) &&
            (identical(other.spacing, spacing) ||
                const DeepCollectionEquality()
                    .equals(other.spacing, spacing)) &&
            (identical(other.insets, insets) ||
                const DeepCollectionEquality().equals(other.insets, insets)) &&
            (identical(other.durations, durations) ||
                const DeepCollectionEquality()
                    .equals(other.durations, durations)) &&
            (identical(other.borderRadius, borderRadius) ||
                const DeepCollectionEquality()
                    .equals(other.borderRadius, borderRadius)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(colorMode) ^
      const DeepCollectionEquality().hash(sizeMode) ^
      const DeepCollectionEquality().hash(maxContentWidth) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(colors) ^
      const DeepCollectionEquality().hash(spacing) ^
      const DeepCollectionEquality().hash(insets) ^
      const DeepCollectionEquality().hash(durations) ^
      const DeepCollectionEquality().hash(borderRadius);

  @override
  _$AdaptativeThemeDataCopyWith<_AdaptativeThemeData> get copyWith =>
      __$AdaptativeThemeDataCopyWithImpl<_AdaptativeThemeData>(
          this, _$identity);
}

abstract class _AdaptativeThemeData implements AdaptativeThemeData {
  const factory _AdaptativeThemeData(
          {@required AdaptativeColorMode colorMode,
          @required AdaptativeSizeMode sizeMode,
          @required double maxContentWidth,
          @required AdaptativeThemeTextStylesData text,
          @required AdaptativeThemeColorsData colors,
          @required AdaptativeThemeSpacingData spacing,
          @required AdaptativeThemeInsetsData insets,
          @required AdaptativeThemeDurationsData durations,
          @required AdaptativeThemeBorderRadiusData borderRadius}) =
      _$_AdaptativeThemeData;

  @override
  AdaptativeColorMode get colorMode;
  @override
  AdaptativeSizeMode get sizeMode;
  @override
  double get maxContentWidth;
  @override
  AdaptativeThemeTextStylesData get text;
  @override
  AdaptativeThemeColorsData get colors;
  @override
  AdaptativeThemeSpacingData get spacing;
  @override
  AdaptativeThemeInsetsData get insets;
  @override
  AdaptativeThemeDurationsData get durations;
  @override
  AdaptativeThemeBorderRadiusData get borderRadius;
  @override
  _$AdaptativeThemeDataCopyWith<_AdaptativeThemeData> get copyWith;
}

/// @nodoc
class _$AdaptativeThemeColorsDataTearOff {
  const _$AdaptativeThemeColorsDataTearOff();

// ignore: unused_element
  _AdaptativeThemeColorsData call(
      {@required Color black1,
      @required Color black2,
      @required Color black3,
      @required Color white1,
      @required Color white2,
      @required Color grey}) {
    return _AdaptativeThemeColorsData(
      black1: black1,
      black2: black2,
      black3: black3,
      white1: white1,
      white2: white2,
      grey: grey,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $AdaptativeThemeColorsData = _$AdaptativeThemeColorsDataTearOff();

/// @nodoc
mixin _$AdaptativeThemeColorsData {
  Color get black1;
  Color get black2;
  Color get black3;
  Color get white1;
  Color get white2;
  Color get grey;

  $AdaptativeThemeColorsDataCopyWith<AdaptativeThemeColorsData> get copyWith;
}

/// @nodoc
abstract class $AdaptativeThemeColorsDataCopyWith<$Res> {
  factory $AdaptativeThemeColorsDataCopyWith(AdaptativeThemeColorsData value,
          $Res Function(AdaptativeThemeColorsData) then) =
      _$AdaptativeThemeColorsDataCopyWithImpl<$Res>;
  $Res call(
      {Color black1,
      Color black2,
      Color black3,
      Color white1,
      Color white2,
      Color grey});
}

/// @nodoc
class _$AdaptativeThemeColorsDataCopyWithImpl<$Res>
    implements $AdaptativeThemeColorsDataCopyWith<$Res> {
  _$AdaptativeThemeColorsDataCopyWithImpl(this._value, this._then);

  final AdaptativeThemeColorsData _value;
  // ignore: unused_field
  final $Res Function(AdaptativeThemeColorsData) _then;

  @override
  $Res call({
    Object black1 = freezed,
    Object black2 = freezed,
    Object black3 = freezed,
    Object white1 = freezed,
    Object white2 = freezed,
    Object grey = freezed,
  }) {
    return _then(_value.copyWith(
      black1: black1 == freezed ? _value.black1 : black1 as Color,
      black2: black2 == freezed ? _value.black2 : black2 as Color,
      black3: black3 == freezed ? _value.black3 : black3 as Color,
      white1: white1 == freezed ? _value.white1 : white1 as Color,
      white2: white2 == freezed ? _value.white2 : white2 as Color,
      grey: grey == freezed ? _value.grey : grey as Color,
    ));
  }
}

/// @nodoc
abstract class _$AdaptativeThemeColorsDataCopyWith<$Res>
    implements $AdaptativeThemeColorsDataCopyWith<$Res> {
  factory _$AdaptativeThemeColorsDataCopyWith(_AdaptativeThemeColorsData value,
          $Res Function(_AdaptativeThemeColorsData) then) =
      __$AdaptativeThemeColorsDataCopyWithImpl<$Res>;
  @override
  $Res call(
      {Color black1,
      Color black2,
      Color black3,
      Color white1,
      Color white2,
      Color grey});
}

/// @nodoc
class __$AdaptativeThemeColorsDataCopyWithImpl<$Res>
    extends _$AdaptativeThemeColorsDataCopyWithImpl<$Res>
    implements _$AdaptativeThemeColorsDataCopyWith<$Res> {
  __$AdaptativeThemeColorsDataCopyWithImpl(_AdaptativeThemeColorsData _value,
      $Res Function(_AdaptativeThemeColorsData) _then)
      : super(_value, (v) => _then(v as _AdaptativeThemeColorsData));

  @override
  _AdaptativeThemeColorsData get _value =>
      super._value as _AdaptativeThemeColorsData;

  @override
  $Res call({
    Object black1 = freezed,
    Object black2 = freezed,
    Object black3 = freezed,
    Object white1 = freezed,
    Object white2 = freezed,
    Object grey = freezed,
  }) {
    return _then(_AdaptativeThemeColorsData(
      black1: black1 == freezed ? _value.black1 : black1 as Color,
      black2: black2 == freezed ? _value.black2 : black2 as Color,
      black3: black3 == freezed ? _value.black3 : black3 as Color,
      white1: white1 == freezed ? _value.white1 : white1 as Color,
      white2: white2 == freezed ? _value.white2 : white2 as Color,
      grey: grey == freezed ? _value.grey : grey as Color,
    ));
  }
}

/// @nodoc
class _$_AdaptativeThemeColorsData implements _AdaptativeThemeColorsData {
  const _$_AdaptativeThemeColorsData(
      {@required this.black1,
      @required this.black2,
      @required this.black3,
      @required this.white1,
      @required this.white2,
      @required this.grey})
      : assert(black1 != null),
        assert(black2 != null),
        assert(black3 != null),
        assert(white1 != null),
        assert(white2 != null),
        assert(grey != null);

  @override
  final Color black1;
  @override
  final Color black2;
  @override
  final Color black3;
  @override
  final Color white1;
  @override
  final Color white2;
  @override
  final Color grey;

  @override
  String toString() {
    return 'AdaptativeThemeColorsData(black1: $black1, black2: $black2, black3: $black3, white1: $white1, white2: $white2, grey: $grey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AdaptativeThemeColorsData &&
            (identical(other.black1, black1) ||
                const DeepCollectionEquality().equals(other.black1, black1)) &&
            (identical(other.black2, black2) ||
                const DeepCollectionEquality().equals(other.black2, black2)) &&
            (identical(other.black3, black3) ||
                const DeepCollectionEquality().equals(other.black3, black3)) &&
            (identical(other.white1, white1) ||
                const DeepCollectionEquality().equals(other.white1, white1)) &&
            (identical(other.white2, white2) ||
                const DeepCollectionEquality().equals(other.white2, white2)) &&
            (identical(other.grey, grey) ||
                const DeepCollectionEquality().equals(other.grey, grey)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(black1) ^
      const DeepCollectionEquality().hash(black2) ^
      const DeepCollectionEquality().hash(black3) ^
      const DeepCollectionEquality().hash(white1) ^
      const DeepCollectionEquality().hash(white2) ^
      const DeepCollectionEquality().hash(grey);

  @override
  _$AdaptativeThemeColorsDataCopyWith<_AdaptativeThemeColorsData>
      get copyWith =>
          __$AdaptativeThemeColorsDataCopyWithImpl<_AdaptativeThemeColorsData>(
              this, _$identity);
}

abstract class _AdaptativeThemeColorsData implements AdaptativeThemeColorsData {
  const factory _AdaptativeThemeColorsData(
      {@required Color black1,
      @required Color black2,
      @required Color black3,
      @required Color white1,
      @required Color white2,
      @required Color grey}) = _$_AdaptativeThemeColorsData;

  @override
  Color get black1;
  @override
  Color get black2;
  @override
  Color get black3;
  @override
  Color get white1;
  @override
  Color get white2;
  @override
  Color get grey;
  @override
  _$AdaptativeThemeColorsDataCopyWith<_AdaptativeThemeColorsData> get copyWith;
}

/// @nodoc
class _$AdaptativeThemeTextStylesDataTearOff {
  const _$AdaptativeThemeTextStylesDataTearOff();

// ignore: unused_element
  _AdaptativeThemeTextStylesData call(
      {@required TextStyle big,
      @required TextStyle regular,
      @required TextStyle small}) {
    return _AdaptativeThemeTextStylesData(
      big: big,
      regular: regular,
      small: small,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $AdaptativeThemeTextStylesData = _$AdaptativeThemeTextStylesDataTearOff();

/// @nodoc
mixin _$AdaptativeThemeTextStylesData {
  TextStyle get big;
  TextStyle get regular;
  TextStyle get small;

  $AdaptativeThemeTextStylesDataCopyWith<AdaptativeThemeTextStylesData>
      get copyWith;
}

/// @nodoc
abstract class $AdaptativeThemeTextStylesDataCopyWith<$Res> {
  factory $AdaptativeThemeTextStylesDataCopyWith(
          AdaptativeThemeTextStylesData value,
          $Res Function(AdaptativeThemeTextStylesData) then) =
      _$AdaptativeThemeTextStylesDataCopyWithImpl<$Res>;
  $Res call({TextStyle big, TextStyle regular, TextStyle small});
}

/// @nodoc
class _$AdaptativeThemeTextStylesDataCopyWithImpl<$Res>
    implements $AdaptativeThemeTextStylesDataCopyWith<$Res> {
  _$AdaptativeThemeTextStylesDataCopyWithImpl(this._value, this._then);

  final AdaptativeThemeTextStylesData _value;
  // ignore: unused_field
  final $Res Function(AdaptativeThemeTextStylesData) _then;

  @override
  $Res call({
    Object big = freezed,
    Object regular = freezed,
    Object small = freezed,
  }) {
    return _then(_value.copyWith(
      big: big == freezed ? _value.big : big as TextStyle,
      regular: regular == freezed ? _value.regular : regular as TextStyle,
      small: small == freezed ? _value.small : small as TextStyle,
    ));
  }
}

/// @nodoc
abstract class _$AdaptativeThemeTextStylesDataCopyWith<$Res>
    implements $AdaptativeThemeTextStylesDataCopyWith<$Res> {
  factory _$AdaptativeThemeTextStylesDataCopyWith(
          _AdaptativeThemeTextStylesData value,
          $Res Function(_AdaptativeThemeTextStylesData) then) =
      __$AdaptativeThemeTextStylesDataCopyWithImpl<$Res>;
  @override
  $Res call({TextStyle big, TextStyle regular, TextStyle small});
}

/// @nodoc
class __$AdaptativeThemeTextStylesDataCopyWithImpl<$Res>
    extends _$AdaptativeThemeTextStylesDataCopyWithImpl<$Res>
    implements _$AdaptativeThemeTextStylesDataCopyWith<$Res> {
  __$AdaptativeThemeTextStylesDataCopyWithImpl(
      _AdaptativeThemeTextStylesData _value,
      $Res Function(_AdaptativeThemeTextStylesData) _then)
      : super(_value, (v) => _then(v as _AdaptativeThemeTextStylesData));

  @override
  _AdaptativeThemeTextStylesData get _value =>
      super._value as _AdaptativeThemeTextStylesData;

  @override
  $Res call({
    Object big = freezed,
    Object regular = freezed,
    Object small = freezed,
  }) {
    return _then(_AdaptativeThemeTextStylesData(
      big: big == freezed ? _value.big : big as TextStyle,
      regular: regular == freezed ? _value.regular : regular as TextStyle,
      small: small == freezed ? _value.small : small as TextStyle,
    ));
  }
}

/// @nodoc
class _$_AdaptativeThemeTextStylesData
    implements _AdaptativeThemeTextStylesData {
  const _$_AdaptativeThemeTextStylesData(
      {@required this.big, @required this.regular, @required this.small})
      : assert(big != null),
        assert(regular != null),
        assert(small != null);

  @override
  final TextStyle big;
  @override
  final TextStyle regular;
  @override
  final TextStyle small;

  @override
  String toString() {
    return 'AdaptativeThemeTextStylesData(big: $big, regular: $regular, small: $small)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AdaptativeThemeTextStylesData &&
            (identical(other.big, big) ||
                const DeepCollectionEquality().equals(other.big, big)) &&
            (identical(other.regular, regular) ||
                const DeepCollectionEquality()
                    .equals(other.regular, regular)) &&
            (identical(other.small, small) ||
                const DeepCollectionEquality().equals(other.small, small)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(big) ^
      const DeepCollectionEquality().hash(regular) ^
      const DeepCollectionEquality().hash(small);

  @override
  _$AdaptativeThemeTextStylesDataCopyWith<_AdaptativeThemeTextStylesData>
      get copyWith => __$AdaptativeThemeTextStylesDataCopyWithImpl<
          _AdaptativeThemeTextStylesData>(this, _$identity);
}

abstract class _AdaptativeThemeTextStylesData
    implements AdaptativeThemeTextStylesData {
  const factory _AdaptativeThemeTextStylesData(
      {@required TextStyle big,
      @required TextStyle regular,
      @required TextStyle small}) = _$_AdaptativeThemeTextStylesData;

  @override
  TextStyle get big;
  @override
  TextStyle get regular;
  @override
  TextStyle get small;
  @override
  _$AdaptativeThemeTextStylesDataCopyWith<_AdaptativeThemeTextStylesData>
      get copyWith;
}

/// @nodoc
class _$AdaptativeThemeSpacingDataTearOff {
  const _$AdaptativeThemeSpacingDataTearOff();

// ignore: unused_element
  _AdaptativeThemeSpacingData call(
      {@required double small,
      @required double regular,
      @required double big}) {
    return _AdaptativeThemeSpacingData(
      small: small,
      regular: regular,
      big: big,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $AdaptativeThemeSpacingData = _$AdaptativeThemeSpacingDataTearOff();

/// @nodoc
mixin _$AdaptativeThemeSpacingData {
  double get small;
  double get regular;
  double get big;

  $AdaptativeThemeSpacingDataCopyWith<AdaptativeThemeSpacingData> get copyWith;
}

/// @nodoc
abstract class $AdaptativeThemeSpacingDataCopyWith<$Res> {
  factory $AdaptativeThemeSpacingDataCopyWith(AdaptativeThemeSpacingData value,
          $Res Function(AdaptativeThemeSpacingData) then) =
      _$AdaptativeThemeSpacingDataCopyWithImpl<$Res>;
  $Res call({double small, double regular, double big});
}

/// @nodoc
class _$AdaptativeThemeSpacingDataCopyWithImpl<$Res>
    implements $AdaptativeThemeSpacingDataCopyWith<$Res> {
  _$AdaptativeThemeSpacingDataCopyWithImpl(this._value, this._then);

  final AdaptativeThemeSpacingData _value;
  // ignore: unused_field
  final $Res Function(AdaptativeThemeSpacingData) _then;

  @override
  $Res call({
    Object small = freezed,
    Object regular = freezed,
    Object big = freezed,
  }) {
    return _then(_value.copyWith(
      small: small == freezed ? _value.small : small as double,
      regular: regular == freezed ? _value.regular : regular as double,
      big: big == freezed ? _value.big : big as double,
    ));
  }
}

/// @nodoc
abstract class _$AdaptativeThemeSpacingDataCopyWith<$Res>
    implements $AdaptativeThemeSpacingDataCopyWith<$Res> {
  factory _$AdaptativeThemeSpacingDataCopyWith(
          _AdaptativeThemeSpacingData value,
          $Res Function(_AdaptativeThemeSpacingData) then) =
      __$AdaptativeThemeSpacingDataCopyWithImpl<$Res>;
  @override
  $Res call({double small, double regular, double big});
}

/// @nodoc
class __$AdaptativeThemeSpacingDataCopyWithImpl<$Res>
    extends _$AdaptativeThemeSpacingDataCopyWithImpl<$Res>
    implements _$AdaptativeThemeSpacingDataCopyWith<$Res> {
  __$AdaptativeThemeSpacingDataCopyWithImpl(_AdaptativeThemeSpacingData _value,
      $Res Function(_AdaptativeThemeSpacingData) _then)
      : super(_value, (v) => _then(v as _AdaptativeThemeSpacingData));

  @override
  _AdaptativeThemeSpacingData get _value =>
      super._value as _AdaptativeThemeSpacingData;

  @override
  $Res call({
    Object small = freezed,
    Object regular = freezed,
    Object big = freezed,
  }) {
    return _then(_AdaptativeThemeSpacingData(
      small: small == freezed ? _value.small : small as double,
      regular: regular == freezed ? _value.regular : regular as double,
      big: big == freezed ? _value.big : big as double,
    ));
  }
}

/// @nodoc
class _$_AdaptativeThemeSpacingData implements _AdaptativeThemeSpacingData {
  const _$_AdaptativeThemeSpacingData(
      {@required this.small, @required this.regular, @required this.big})
      : assert(small != null),
        assert(regular != null),
        assert(big != null);

  @override
  final double small;
  @override
  final double regular;
  @override
  final double big;

  @override
  String toString() {
    return 'AdaptativeThemeSpacingData(small: $small, regular: $regular, big: $big)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AdaptativeThemeSpacingData &&
            (identical(other.small, small) ||
                const DeepCollectionEquality().equals(other.small, small)) &&
            (identical(other.regular, regular) ||
                const DeepCollectionEquality()
                    .equals(other.regular, regular)) &&
            (identical(other.big, big) ||
                const DeepCollectionEquality().equals(other.big, big)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(small) ^
      const DeepCollectionEquality().hash(regular) ^
      const DeepCollectionEquality().hash(big);

  @override
  _$AdaptativeThemeSpacingDataCopyWith<_AdaptativeThemeSpacingData>
      get copyWith => __$AdaptativeThemeSpacingDataCopyWithImpl<
          _AdaptativeThemeSpacingData>(this, _$identity);
}

abstract class _AdaptativeThemeSpacingData
    implements AdaptativeThemeSpacingData {
  const factory _AdaptativeThemeSpacingData(
      {@required double small,
      @required double regular,
      @required double big}) = _$_AdaptativeThemeSpacingData;

  @override
  double get small;
  @override
  double get regular;
  @override
  double get big;
  @override
  _$AdaptativeThemeSpacingDataCopyWith<_AdaptativeThemeSpacingData>
      get copyWith;
}

/// @nodoc
class _$AdaptativeThemeInsetsDataTearOff {
  const _$AdaptativeThemeInsetsDataTearOff();

// ignore: unused_element
  _AdaptativeThemeInsetsData call(
      {@required EdgeInsets small,
      @required EdgeInsets regular,
      @required EdgeInsets big}) {
    return _AdaptativeThemeInsetsData(
      small: small,
      regular: regular,
      big: big,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $AdaptativeThemeInsetsData = _$AdaptativeThemeInsetsDataTearOff();

/// @nodoc
mixin _$AdaptativeThemeInsetsData {
  EdgeInsets get small;
  EdgeInsets get regular;
  EdgeInsets get big;

  $AdaptativeThemeInsetsDataCopyWith<AdaptativeThemeInsetsData> get copyWith;
}

/// @nodoc
abstract class $AdaptativeThemeInsetsDataCopyWith<$Res> {
  factory $AdaptativeThemeInsetsDataCopyWith(AdaptativeThemeInsetsData value,
          $Res Function(AdaptativeThemeInsetsData) then) =
      _$AdaptativeThemeInsetsDataCopyWithImpl<$Res>;
  $Res call({EdgeInsets small, EdgeInsets regular, EdgeInsets big});
}

/// @nodoc
class _$AdaptativeThemeInsetsDataCopyWithImpl<$Res>
    implements $AdaptativeThemeInsetsDataCopyWith<$Res> {
  _$AdaptativeThemeInsetsDataCopyWithImpl(this._value, this._then);

  final AdaptativeThemeInsetsData _value;
  // ignore: unused_field
  final $Res Function(AdaptativeThemeInsetsData) _then;

  @override
  $Res call({
    Object small = freezed,
    Object regular = freezed,
    Object big = freezed,
  }) {
    return _then(_value.copyWith(
      small: small == freezed ? _value.small : small as EdgeInsets,
      regular: regular == freezed ? _value.regular : regular as EdgeInsets,
      big: big == freezed ? _value.big : big as EdgeInsets,
    ));
  }
}

/// @nodoc
abstract class _$AdaptativeThemeInsetsDataCopyWith<$Res>
    implements $AdaptativeThemeInsetsDataCopyWith<$Res> {
  factory _$AdaptativeThemeInsetsDataCopyWith(_AdaptativeThemeInsetsData value,
          $Res Function(_AdaptativeThemeInsetsData) then) =
      __$AdaptativeThemeInsetsDataCopyWithImpl<$Res>;
  @override
  $Res call({EdgeInsets small, EdgeInsets regular, EdgeInsets big});
}

/// @nodoc
class __$AdaptativeThemeInsetsDataCopyWithImpl<$Res>
    extends _$AdaptativeThemeInsetsDataCopyWithImpl<$Res>
    implements _$AdaptativeThemeInsetsDataCopyWith<$Res> {
  __$AdaptativeThemeInsetsDataCopyWithImpl(_AdaptativeThemeInsetsData _value,
      $Res Function(_AdaptativeThemeInsetsData) _then)
      : super(_value, (v) => _then(v as _AdaptativeThemeInsetsData));

  @override
  _AdaptativeThemeInsetsData get _value =>
      super._value as _AdaptativeThemeInsetsData;

  @override
  $Res call({
    Object small = freezed,
    Object regular = freezed,
    Object big = freezed,
  }) {
    return _then(_AdaptativeThemeInsetsData(
      small: small == freezed ? _value.small : small as EdgeInsets,
      regular: regular == freezed ? _value.regular : regular as EdgeInsets,
      big: big == freezed ? _value.big : big as EdgeInsets,
    ));
  }
}

/// @nodoc
class _$_AdaptativeThemeInsetsData implements _AdaptativeThemeInsetsData {
  const _$_AdaptativeThemeInsetsData(
      {@required this.small, @required this.regular, @required this.big})
      : assert(small != null),
        assert(regular != null),
        assert(big != null);

  @override
  final EdgeInsets small;
  @override
  final EdgeInsets regular;
  @override
  final EdgeInsets big;

  @override
  String toString() {
    return 'AdaptativeThemeInsetsData(small: $small, regular: $regular, big: $big)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AdaptativeThemeInsetsData &&
            (identical(other.small, small) ||
                const DeepCollectionEquality().equals(other.small, small)) &&
            (identical(other.regular, regular) ||
                const DeepCollectionEquality()
                    .equals(other.regular, regular)) &&
            (identical(other.big, big) ||
                const DeepCollectionEquality().equals(other.big, big)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(small) ^
      const DeepCollectionEquality().hash(regular) ^
      const DeepCollectionEquality().hash(big);

  @override
  _$AdaptativeThemeInsetsDataCopyWith<_AdaptativeThemeInsetsData>
      get copyWith =>
          __$AdaptativeThemeInsetsDataCopyWithImpl<_AdaptativeThemeInsetsData>(
              this, _$identity);
}

abstract class _AdaptativeThemeInsetsData implements AdaptativeThemeInsetsData {
  const factory _AdaptativeThemeInsetsData(
      {@required EdgeInsets small,
      @required EdgeInsets regular,
      @required EdgeInsets big}) = _$_AdaptativeThemeInsetsData;

  @override
  EdgeInsets get small;
  @override
  EdgeInsets get regular;
  @override
  EdgeInsets get big;
  @override
  _$AdaptativeThemeInsetsDataCopyWith<_AdaptativeThemeInsetsData> get copyWith;
}

/// @nodoc
class _$AdaptativeThemeDurationsDataTearOff {
  const _$AdaptativeThemeDurationsDataTearOff();

// ignore: unused_element
  _AdaptativeThemeDurationsData call(
      {@required Duration quick,
      @required Duration regular,
      @required Duration slow}) {
    return _AdaptativeThemeDurationsData(
      quick: quick,
      regular: regular,
      slow: slow,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $AdaptativeThemeDurationsData = _$AdaptativeThemeDurationsDataTearOff();

/// @nodoc
mixin _$AdaptativeThemeDurationsData {
  Duration get quick;
  Duration get regular;
  Duration get slow;

  $AdaptativeThemeDurationsDataCopyWith<AdaptativeThemeDurationsData>
      get copyWith;
}

/// @nodoc
abstract class $AdaptativeThemeDurationsDataCopyWith<$Res> {
  factory $AdaptativeThemeDurationsDataCopyWith(
          AdaptativeThemeDurationsData value,
          $Res Function(AdaptativeThemeDurationsData) then) =
      _$AdaptativeThemeDurationsDataCopyWithImpl<$Res>;
  $Res call({Duration quick, Duration regular, Duration slow});
}

/// @nodoc
class _$AdaptativeThemeDurationsDataCopyWithImpl<$Res>
    implements $AdaptativeThemeDurationsDataCopyWith<$Res> {
  _$AdaptativeThemeDurationsDataCopyWithImpl(this._value, this._then);

  final AdaptativeThemeDurationsData _value;
  // ignore: unused_field
  final $Res Function(AdaptativeThemeDurationsData) _then;

  @override
  $Res call({
    Object quick = freezed,
    Object regular = freezed,
    Object slow = freezed,
  }) {
    return _then(_value.copyWith(
      quick: quick == freezed ? _value.quick : quick as Duration,
      regular: regular == freezed ? _value.regular : regular as Duration,
      slow: slow == freezed ? _value.slow : slow as Duration,
    ));
  }
}

/// @nodoc
abstract class _$AdaptativeThemeDurationsDataCopyWith<$Res>
    implements $AdaptativeThemeDurationsDataCopyWith<$Res> {
  factory _$AdaptativeThemeDurationsDataCopyWith(
          _AdaptativeThemeDurationsData value,
          $Res Function(_AdaptativeThemeDurationsData) then) =
      __$AdaptativeThemeDurationsDataCopyWithImpl<$Res>;
  @override
  $Res call({Duration quick, Duration regular, Duration slow});
}

/// @nodoc
class __$AdaptativeThemeDurationsDataCopyWithImpl<$Res>
    extends _$AdaptativeThemeDurationsDataCopyWithImpl<$Res>
    implements _$AdaptativeThemeDurationsDataCopyWith<$Res> {
  __$AdaptativeThemeDurationsDataCopyWithImpl(
      _AdaptativeThemeDurationsData _value,
      $Res Function(_AdaptativeThemeDurationsData) _then)
      : super(_value, (v) => _then(v as _AdaptativeThemeDurationsData));

  @override
  _AdaptativeThemeDurationsData get _value =>
      super._value as _AdaptativeThemeDurationsData;

  @override
  $Res call({
    Object quick = freezed,
    Object regular = freezed,
    Object slow = freezed,
  }) {
    return _then(_AdaptativeThemeDurationsData(
      quick: quick == freezed ? _value.quick : quick as Duration,
      regular: regular == freezed ? _value.regular : regular as Duration,
      slow: slow == freezed ? _value.slow : slow as Duration,
    ));
  }
}

/// @nodoc
class _$_AdaptativeThemeDurationsData implements _AdaptativeThemeDurationsData {
  const _$_AdaptativeThemeDurationsData(
      {@required this.quick, @required this.regular, @required this.slow})
      : assert(quick != null),
        assert(regular != null),
        assert(slow != null);

  @override
  final Duration quick;
  @override
  final Duration regular;
  @override
  final Duration slow;

  @override
  String toString() {
    return 'AdaptativeThemeDurationsData(quick: $quick, regular: $regular, slow: $slow)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AdaptativeThemeDurationsData &&
            (identical(other.quick, quick) ||
                const DeepCollectionEquality().equals(other.quick, quick)) &&
            (identical(other.regular, regular) ||
                const DeepCollectionEquality()
                    .equals(other.regular, regular)) &&
            (identical(other.slow, slow) ||
                const DeepCollectionEquality().equals(other.slow, slow)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(quick) ^
      const DeepCollectionEquality().hash(regular) ^
      const DeepCollectionEquality().hash(slow);

  @override
  _$AdaptativeThemeDurationsDataCopyWith<_AdaptativeThemeDurationsData>
      get copyWith => __$AdaptativeThemeDurationsDataCopyWithImpl<
          _AdaptativeThemeDurationsData>(this, _$identity);
}

abstract class _AdaptativeThemeDurationsData
    implements AdaptativeThemeDurationsData {
  const factory _AdaptativeThemeDurationsData(
      {@required Duration quick,
      @required Duration regular,
      @required Duration slow}) = _$_AdaptativeThemeDurationsData;

  @override
  Duration get quick;
  @override
  Duration get regular;
  @override
  Duration get slow;
  @override
  _$AdaptativeThemeDurationsDataCopyWith<_AdaptativeThemeDurationsData>
      get copyWith;
}

/// @nodoc
class _$AdaptativeThemeBorderRadiusDataTearOff {
  const _$AdaptativeThemeBorderRadiusDataTearOff();

// ignore: unused_element
  _AdaptativeThemeBorderRadiusData call(
      {@required BorderRadius small,
      @required BorderRadius regular,
      @required BorderRadius big}) {
    return _AdaptativeThemeBorderRadiusData(
      small: small,
      regular: regular,
      big: big,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $AdaptativeThemeBorderRadiusData =
    _$AdaptativeThemeBorderRadiusDataTearOff();

/// @nodoc
mixin _$AdaptativeThemeBorderRadiusData {
  BorderRadius get small;
  BorderRadius get regular;
  BorderRadius get big;

  $AdaptativeThemeBorderRadiusDataCopyWith<AdaptativeThemeBorderRadiusData>
      get copyWith;
}

/// @nodoc
abstract class $AdaptativeThemeBorderRadiusDataCopyWith<$Res> {
  factory $AdaptativeThemeBorderRadiusDataCopyWith(
          AdaptativeThemeBorderRadiusData value,
          $Res Function(AdaptativeThemeBorderRadiusData) then) =
      _$AdaptativeThemeBorderRadiusDataCopyWithImpl<$Res>;
  $Res call({BorderRadius small, BorderRadius regular, BorderRadius big});
}

/// @nodoc
class _$AdaptativeThemeBorderRadiusDataCopyWithImpl<$Res>
    implements $AdaptativeThemeBorderRadiusDataCopyWith<$Res> {
  _$AdaptativeThemeBorderRadiusDataCopyWithImpl(this._value, this._then);

  final AdaptativeThemeBorderRadiusData _value;
  // ignore: unused_field
  final $Res Function(AdaptativeThemeBorderRadiusData) _then;

  @override
  $Res call({
    Object small = freezed,
    Object regular = freezed,
    Object big = freezed,
  }) {
    return _then(_value.copyWith(
      small: small == freezed ? _value.small : small as BorderRadius,
      regular: regular == freezed ? _value.regular : regular as BorderRadius,
      big: big == freezed ? _value.big : big as BorderRadius,
    ));
  }
}

/// @nodoc
abstract class _$AdaptativeThemeBorderRadiusDataCopyWith<$Res>
    implements $AdaptativeThemeBorderRadiusDataCopyWith<$Res> {
  factory _$AdaptativeThemeBorderRadiusDataCopyWith(
          _AdaptativeThemeBorderRadiusData value,
          $Res Function(_AdaptativeThemeBorderRadiusData) then) =
      __$AdaptativeThemeBorderRadiusDataCopyWithImpl<$Res>;
  @override
  $Res call({BorderRadius small, BorderRadius regular, BorderRadius big});
}

/// @nodoc
class __$AdaptativeThemeBorderRadiusDataCopyWithImpl<$Res>
    extends _$AdaptativeThemeBorderRadiusDataCopyWithImpl<$Res>
    implements _$AdaptativeThemeBorderRadiusDataCopyWith<$Res> {
  __$AdaptativeThemeBorderRadiusDataCopyWithImpl(
      _AdaptativeThemeBorderRadiusData _value,
      $Res Function(_AdaptativeThemeBorderRadiusData) _then)
      : super(_value, (v) => _then(v as _AdaptativeThemeBorderRadiusData));

  @override
  _AdaptativeThemeBorderRadiusData get _value =>
      super._value as _AdaptativeThemeBorderRadiusData;

  @override
  $Res call({
    Object small = freezed,
    Object regular = freezed,
    Object big = freezed,
  }) {
    return _then(_AdaptativeThemeBorderRadiusData(
      small: small == freezed ? _value.small : small as BorderRadius,
      regular: regular == freezed ? _value.regular : regular as BorderRadius,
      big: big == freezed ? _value.big : big as BorderRadius,
    ));
  }
}

/// @nodoc
class _$_AdaptativeThemeBorderRadiusData
    implements _AdaptativeThemeBorderRadiusData {
  const _$_AdaptativeThemeBorderRadiusData(
      {@required this.small, @required this.regular, @required this.big})
      : assert(small != null),
        assert(regular != null),
        assert(big != null);

  @override
  final BorderRadius small;
  @override
  final BorderRadius regular;
  @override
  final BorderRadius big;

  @override
  String toString() {
    return 'AdaptativeThemeBorderRadiusData(small: $small, regular: $regular, big: $big)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AdaptativeThemeBorderRadiusData &&
            (identical(other.small, small) ||
                const DeepCollectionEquality().equals(other.small, small)) &&
            (identical(other.regular, regular) ||
                const DeepCollectionEquality()
                    .equals(other.regular, regular)) &&
            (identical(other.big, big) ||
                const DeepCollectionEquality().equals(other.big, big)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(small) ^
      const DeepCollectionEquality().hash(regular) ^
      const DeepCollectionEquality().hash(big);

  @override
  _$AdaptativeThemeBorderRadiusDataCopyWith<_AdaptativeThemeBorderRadiusData>
      get copyWith => __$AdaptativeThemeBorderRadiusDataCopyWithImpl<
          _AdaptativeThemeBorderRadiusData>(this, _$identity);
}

abstract class _AdaptativeThemeBorderRadiusData
    implements AdaptativeThemeBorderRadiusData {
  const factory _AdaptativeThemeBorderRadiusData(
      {@required BorderRadius small,
      @required BorderRadius regular,
      @required BorderRadius big}) = _$_AdaptativeThemeBorderRadiusData;

  @override
  BorderRadius get small;
  @override
  BorderRadius get regular;
  @override
  BorderRadius get big;
  @override
  _$AdaptativeThemeBorderRadiusDataCopyWith<_AdaptativeThemeBorderRadiusData>
      get copyWith;
}
